<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[setTimeout&Promise&Async之间的爱恨情仇]]></title>
    <url>%2F2019%2F02%2F22%2FsetTimeout-Promise-Async%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[春节之后又到了换工作的高峰期，我换工作时候也遇到了这道面试题，这里将我前面写的文章保存在博客方便以后复习使用。setTimeout一、setTimeout 初现定义：setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 语法：12setTimeout(code, milliseconds, param1, param2, ...)setTimeout(function, milliseconds, param1, param2, ...)参数描述code/function必需。要调用一个代码串，也可以是一个函数milliseconds可选。执行或调用 code/function 需要等待的时间，以毫秒计。默认为 0。param1, param2, …可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。二、setTimeout 初识第一种1234567891011121314setTimeout(fn1, 1000);setTimeout(fn2, 2000);setTimeout(function fn3()&#123;console.log(3);&#125;, 3000);setTimeout(function ()&#123;console.log(4);&#125;, 4000);function fn1()&#123; console.log(1);&#125;var fn2 = function()&#123; console.log(2);&#125;//输出结果如下：// 分别延迟1,2,3,4秒之后输出 1 2 3 4第二种123456789101112131415setTimeout(fn1(), 1000);setTimeout(fn2(), 2000);setTimeout(function fn3()&#123;console.log(3);&#125;(), 3000);setTimeout(function ()&#123;console.log(4);&#125;(), 4000);function fn1()&#123; console.log(1);&#125;var fn2 = function()&#123; console.log(2);&#125;//输出结果如下：//直接输出 1 2 3 4 ,没有延迟按照定义：setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。第一种方法在指定毫秒数之后执行，第二种方法没有在指定毫秒数后执行，而是立刻执行。所以我个人将其分成正规军setTimeout和杂牌军setTimeout，方便后面记忆。正规军我们在后面详细讲，现在先了解下杂牌军：由于setTimeout()的第一个参数是直接可执行的代码，所以它没有任何延迟效果，如下：12345setTimeout(console.log(1), 1000);//输出结果如下：//直接输出 1 ,没有延迟三、setTimeout 再遇1234567setTimeout(function(a,b)&#123; console.log(a+b);&#125;,1000,4,5);//输出结果如下：//9从第三个参数开始，依次用来表示第一个参数（回调函数）传入的参数一些古老的浏览器是不支持，可以用bind或apply方法来解决,如下：1234567setTimeout(function(a,b)&#123; console.log(a+b);&#125;.bind(this,4,5),1000);//输出结果如下：//9第一个参数表示将原函数的this绑定全局作用域，第二个参数开始是要传入原函数的参数当调用绑定函数时,绑定函数会以创建它时传入bind()方法的第一个参数作为 this四、setTimeout 相知对于setTimeout()的this问题，网上有很多的文章，我就不班门弄斧了，后面若总结的够到位了就写一篇文章介绍下。12345678console.log(1);setTimeout(function ()&#123; console.log(2);&#125;,3000);console.log(3);//输出结果如下：//1 3 2123456789console.log(1);setTimeout(function ()&#123; console.log(2);&#125;,0);console.log(3);//输出结果如下：//1 3 2这里有些同学可能会疑惑，第一段代码延迟三秒之后执行输出1，3，2可以理解，但是第二段代码延迟0秒执行为什么也是会输出1，3，2呢？这里就需要提到“任务队列”这个概念了，由于JavaScript是一种单线程的语言，也就是说同一时间只能做一件事情。但是HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制。单线程意味着，所有的任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等待。所以设计者将任务分成两种，一种 同步任务 ，另一种是 异步任务 。同步任务是，在主线程上排队执行的任务，只有前一个执行完，才能执行后一个；异步任务是，不进入主线程，而是进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。“任务队列”除了放置任务事件，还可以放置定时事件。即指定某些代码在多少时间之后执行。知道了这些我们基本上就可以解释上面两段代码为什么会输出这样的结果了。第一段代码，因为setTimeout()将回调函数推迟了3000毫秒之后执行。如果将setTimeout()第二个参数设置为0，就表示当前代码执行完以后，立刻执行（0毫秒间隔）指定的回调函数。所以只有在打印出1和3之后，系统才会执行“任务队列”中的回调函数。总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。强调一遍：它在”任务队列”的尾部添加一个事件，记住是尾部，添加到”任务队列”尾部，所以后最后执行。HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。所以他们有时候不一定会守时的。守时的都是好孩子！阮一峰老师对任务队列有详细的介绍，详情戳这里五、setTimeout 相熟了解了上面的内容，我们得拉出来溜溜了，直接上测试题：123456789101112console.log(1);setTimeout(fn1, 1000);setTimeout(function()&#123; console.log(2);&#125;,0);setTimeout(console.log(3),2000);function fn1()&#123; console.log(4);&#125;console.log(5);//输出结果：//1 3 5 2 4(4会延迟一秒)1.先执行主线程，打印出1；2.遇到第一个setTimeout,1秒后执行回调函数，所以添加到任务队列；3.遇到第二个setTimeout，0秒后执行回调函数，再次添加到任务队列；4.遇到第三个setTimeout，这个第一个参数不是回调函数，而是一个直接可执行的语句，记得我前面讲过的这个是个杂牌军，它不会添加到任务队列也不会延迟执行而是直接执行，所以打印出3；5.继续执行打印出5；6.第二个setTimeout，由于是0秒延迟所以主线程任务结束立刻执行，所以打印出2；7.最后执行第一个setTimeout，一秒后打印出4.上面的试题明白之后我们就可以明白下面的代码了：1234567var timeoutId = setTimeout(function ()&#123; console("hello World");&#125;,1000); clearTimeout(timeoutId);//输出结果：//不会打印出hello World1先执行主线程，遇到setTimeout并且第一个参数是回调函数，添加到任务队列，1秒后执行；2.执行clearTimeout，则还未等到代码执行就 取消了定时器，所以不会打印出任何内容。下面我们学习下promisepromise一、promise 初现ES6 将promise写进了语言标准，统一了用法，原生提供了Promise对象。详细介绍戳这里阮一峰老师进行了详细的说明；这里我简单的说下，我后面会使用到的内容：Promise 新建后就会立即执行，然后，then方法接受两个回调函数作为参数，将在当前脚本所有同步任务执行完才会执行。记住这里then之后的回调函数才异步执行的，所以会添加到任务队列中。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。二、promise 初识下面我将以代码片段的方式，逐渐看出现的各种面试题，加深大家的理解1234567891011121314console.log(1);new Promise((resolve,reject)=&gt;&#123; console.log(2); resolve()&#125;).then( ()=&gt;&#123; console.log(3)&#125;,()=&gt;&#123; console.log(4);&#125;);console.log(5);//输出结果：//1 2 5 31.先执行主线程，打印出1；Promise 新建后就会立即执行，所以打印出2，执行resolve表明执行成功回调；then的成功执行的是回调函数，所以是异步执行，添加到任务队列之中，暂不执行；继续执行主线程，打印出5；主线程结束之后执行任务队列中的回调函数打印出31234567891011121314console.log(1);new Promise((resolve,reject)=&gt;&#123; console.log(2); reject()&#125;).then( ()=&gt;&#123; console.log(3)&#125;,()=&gt;&#123; console.log(4);&#125;);console.log(5);//输出结果：//1 2 5 4这个例子同上，只是执行的是异步的失败的回调函数，所以最后一个打印出的是41234567891011console.log(1);new Promise((resolve,reject)=&gt;&#123; console.log(2);&#125;).then( ()=&gt;&#123; console.log(3)&#125;);console.log(4);//输出结果：//1 2 4这个例子中打印出4之后没有打印3，是因为promise中没有指定是执行成功回调还是失败的回调所以不会执行then的回调函数123456789console.log(1);new Promise((resolve,reject)=&gt;&#123; console.log(2);&#125;).then(console.log(3));console.log(4);//输出结果：//1 2 3 4看到这个有同学可能就懵了，怎么回事怎么是1234而不是1243呢，这需要考察同学们是否细心呢，看这里then中的直接是可执行的语句而不是回调函数，所以会出现这种情况，异步任务必须是回调函数 如果不是回调函数就是同步的了1.先执行主线程，打印出1；Promise 新建后就会立即执行，所以打印出2；then中不是回调函数而是直接可执行的语句，所以直接执行打印出3；继续执行主线程，打印出4；嘻嘻，看了上面的这些例子相信大家已经对promise理解了不少，所以我们继续深入看看下面这个例子，输出的结果是什么呢？12345678910111213console.log(1);new Promise((resolve,reject)=&gt;&#123; console.log(2); resolve(); console.log(3);&#125;).then( ()=&gt;&#123; console.log(4)&#125;);console.log(5);//输出结果：//1 2 3 5 4大家有没有写对呢？这里大家的疑问估计就是resolve()之后的console.log(3);这个地方咯这是因为上面代码中，调用resolve()以后，后面的console.log(3)还是会执行，并且会首先打印出来。因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。所以如果想让，调用resolve或reject以后，Promise 的使命完成，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。如下：123456789101112console.log(1);new Promise((resolve,reject)=&gt;&#123; console.log(2); return resolve(); console.log(3);&#125;).then( ()=&gt;&#123; console.log(4)&#125;);console.log(5);//输出结果：//1 2 5 4这样console.log(3);是不会执行的。三、promise&amp;setTimeout下面我们在来看如果promise&amp;setTimeout同时出现会发生什么样的情况呢？如下：1234567891011121314151617console.log('a');setTimeout(function() &#123;console.log('b')&#125;, 0);new Promise((resolve, reject) =&gt; &#123; for(let i=0; i&lt;10000000; i++) &#123; if(i==999999) &#123; console.log('c'); resolve(); &#125; &#125; console.log('d');&#125;).then(() =&gt; &#123; console.log('e');&#125;);console.log('f');//输出结果：// a c d f e b大家是不是有些晕，哈哈哈，别着急这里我们得在拓展一点新概念，方便我们理解：事件循环、宏任务和微任务JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务），它们又被称为task与jobs。宏任务（macro-task）大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。微任务（micro-task）大概包括: process.nextTick, Promise, MutationObserver(html5新特性)事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的微任务（micro-task）。当所有可执行的微任务（micro-task）执行完毕之后。循环再次从宏任务（macro-task）开始，找到其中一个任务队列执行完毕，然后再执行所有的微任务（micro-task），这样一直循环下去。注：本篇使用的宏任务（macro-task）：script(整体代码), setTimeout, setInterval；微任务（micro-task）： Promise。至于其他的浏览器没有，引用了node.js的API，如： setImmediate、 process.nextTick等，至于他们的执行顺序可参考这篇文章比如上述例子，不同类型的任务会分别进入到他们所属类型的任务队列，比如所有setTimeout()的回调都会进入到setTimeout任务队列，既宏任务（macro-task）;所有then()回调都会进入到then队列,既微任务（micro-task）。当前的整体代码我们可以认为是宏任务。事件循环从当前整体代码开始第一次事件循环，然后再执行队列中所有的微任务，当微任务执行完毕之后，事件循环再找到其中一个宏任务队列并执行其中的所有任务，然后再找到一个微任务队列并执行里面的所有任务，就这样一直循环下去。这就是我所理解的事件循环。分析上面例子：1.首先执行整体代码，第一个打印出来a2.执行到第一个setTimeout时，发现它是宏任务，此时会新建一个setTimeout类型的宏任务队列并派发当前这个setTimeout的回调函数到刚建好的这个宏任务队列中去3.再执行到new Promise，Promise构造函数中的第一个参数在new的时候会直接执行，因此不会进入任何队列，所以第三个输出是c4.执行完resolve()之后，继续向后执行，打印出d5.上面有说到Promise.then是微任务，那么这里会生成一个Promise.then类型的微任务队列，这里的then回调会被push进这个队列中6.再向后走打印出f7.第一轮事件循环的宏任务执行完成（整体代码看做宏任务）。此时微任务队列中只有一个Promise.then类型微任务队列。宏任务队列中也只有一个setTimeout类型的宏任务队列。8.下面执行第一轮事件循环的微任务，很明显，会打印出e,至此第一轮事件循环完成9.开始第二轮事件循环：执行setTimeout类型队列（宏任务队列）中的所有任务，只有一个任务，所以打印出b10.第二轮事件的宏任务结束，这个事件循环结束。再来一个你中有我我中有你的超级例子，体验下到处是坑的试题，嘿嘿;-)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647console.log('a');setTimeout(function () &#123; console.log('b') new Promise(resolve=&gt; &#123; console.log('c') resolve() &#125;).then(()=&gt; &#123; console.log('d') &#125;)&#125;,2000);new Promise((resolve,reject)=&gt;&#123; console.log('e'); resolve(); console.log('f');&#125;).then(()=&gt;&#123; console.log('g')&#125;);console.log('h');new Promise((resolve,reject)=&gt;&#123; setTimeout(function () &#123; console.log('i'); &#125;,0);&#125;).then(console.log('j'));setTimeout(function () &#123; console.log('k') new Promise(resolve=&gt;&#123; console.log('l') return resolve() console.log('m') &#125;).then(()=&gt;&#123; console.log('n') &#125;)&#125;,1000);console.log('p');//输出结果：//a e f h j p g i//延迟1s 输出：k l n //再延迟1s 输出：b c d1.首先执行整体代码，第一个打印出来”a”;2.执行到第一个setTimeout时，发现它是宏任务，此时会新建一个setTimeout类型的宏任务队列并派发当前这个setTimeout的回调函数到刚建好的这个宏任务队列中去，并且轮到它执行时要延迟2秒后再执行;3.执行到第一个new Promise，Promise构造函数中的第一个参数在new的时候会直接执行，因此不会进入任何队列，所以第二个输出是”e”，resolve()之后的语句会继续执行，所以第三个输出的是”f”,Promise.then是微任务，那么这里会生成一个Promise.then类型的微任务队列，这里的then回调会被push进这个队列中;4.再执行整体代码，第四个打印出来”h”;5.执行到第一个new Promise，Promise构造函数中的第一个参数在new的时候会直接执行，但是这个是一个setTimeout，发现它是宏任务，派发它的回调到上面setTimeout类型的宏任务队列中去。后面Promise.then中是一个可执行的代码，并不是回调函数，所以会直接的执行，并不会添加到微任务中去，所以第五个输出的是：”j”;6.执行到第二个setTimeout时，发现它是宏任务，派发它的回调到上面setTimeout类型的宏任务队列中去，但是会延迟1s执行；7.执行整体代码，第六个输出的是”p”;8.第一轮事件循环的宏任务执行完成（整体代码看做宏任务）。此时微任务队列中只有一个Promise.then类型微任务队列，它里面有一个任务;宏任务队列中也只有一个setTimeout类型的宏任务队列;9.下面执行第一轮事件循环的微任务，很明显，第七个输出的是：”g”。此时第一轮事件循环完成;10.开始第二轮事件循环：执行setTimeout类型队列（宏任务队列）中的所有任务。发现有的有延时有的没有延时，所以先执行延时最短的宏任务；11.执行setTimeout，第八个输出的是”i”;12.紧接着执行延迟1s的setTimeout，所以延迟一秒之后第九个输出的是：”k”;13.之后遇到new Promise，Promise构造函数中的第一个参数在new的时候会直接执行，因此不会进入任何队列，所以第十个输出是”l”，之后是一个return语句，所以后面的代码不会执行，”m”不会被输出出来；14.但这里发现了then，又把它push到上面已经被执行完的then队列中去，这里要注意，因为出现了微任务then队列，所以这里会执行该队列中的所有任务（此时只有一个任务），所以第十一个输出的是”n”;15.再延迟1s执行setTimeout，所以延迟二秒之后第十二个输出的是：”b”;16.之后遇到new Promise，Promise构造函数中的第一个参数在new的时候会直接执行，因此不会进入任何队列，所以第十三个输出是”c”；17.但这里又发现了then，又把它push到上面已经被执行完的then队列中去，这里要注意，因为出现了微任务then队列，所以这里会执行该队列中的所有任务（此时只有一个任务），所以第十四个输出的是”d”;噗，终于完了，不知道大家有没有理解呢？生活就是这样，你以为度过了一个难关前面就是阳光大道，但现实就是这样，他会给你再来一个难题，接着看下面的代码，嘿嘿嘿~~~123456789101112131415161718192021222324252627282930async function async1() &#123; console.log("a"); await async2(); console.log("b");&#125;async function async2() &#123; console.log( 'c');&#125;console.log("d");setTimeout(function () &#123; console.log("e");&#125;,0);async1();new Promise(function (resolve) &#123; console.log("x"); resolve();&#125;).then(function () &#123; console.log("y");&#125;);console.log('z');//输出结果：// d a c x z y b e是不是有点傻了，怎么又出现了async了，别慌别慌且听我慢慢道来，在说之前还得大家了解async，阮一峰老师对此有详细的介绍，详情戳这里Async一、asyncasync的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。我们先来观察下async的返回值，请看下面的代码：12345678910async function testAsync() &#123; return "hello async";&#125;const result = testAsync();console.log(result);//输出结果：// Promise &#123; 'hello async' &#125;看到这里我们知道了，saync输出的是一个promise对象async 函数（包含函数语句、函数表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。那我们试下没有返回值会是怎么样呢？1234567891011async function testAsync() &#123; console.log("hello async");&#125;const result = testAsync();console.log(result);//输出结果：// hello async// Promise &#123; undefined &#125;会返回一个为空的promis对象二、await从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。12345678910111213141516171819function getSomething() &#123; return "something";&#125;async function testAsync() &#123; return Promise.resolve("hello async");&#125;async function test() &#123; const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1, v2);&#125;test();//输出结果：// something hello asyncawait 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西,如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。内容描述语法[return_value] = await expression;表达式（expression）一个 Promise 对象或者任何要等待的值。返回值（return_value）返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身但是当遇到await会怎么执行呢？async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句.即，当遇到async函数体内的 await test();时候，执行test()，然后得到返回值value（可以是promise也可以是其他值），组成await value;,若 value是promise对象时候，此时返回的Promise会被放入到任务队列中等待，await会让出线程，跳出 async函数，继续执行后续代码；若 value是其他值，只是不会被添加到任务队列而已，await也会让出线程，跳出 async函数，继续执行后续代码。明白了这些，我们分析上面最难的那部分代码：1.首先执行整体代码，遇到两个saync函数，没有调用所以继续向下执行，所以第一个输出的是：”d”;2.执行到第一个setTimeout时，发现它是宏任务，此时会新建一个setTimeout类型的宏任务队列并派发当前这个setTimeout的回调函数到刚建好的这个宏任务队列中去，并且轮到它执行时要立刻执行;3.遇到async1()， async1函数调用，执行async1函数，第二个输出的是：”a”;4.然后执行到 await async2()，发现 async2 也是个 async 定义的函数，所以直接执行了“console.log(‘c’)”。所以第三个输出的是：”c”;5.同时async2返回了一个Promise,请注意：此时返回的Promise会被放入到任务队列中等待，await会让出线程，接下来就会跳出 async1函数，继续往下执行！！！6.执行到 new Promise，前面说过了promise是立即执行的，所以第四个输出的是：”x”;7.然后执行到 resolve 的时候，resolve这个任务就被放到任务队列中等待，然后跳出Promise继续往下执行，所以第五个输出的是：”z”;8.现在调用栈空出来了，事件循环就会去任务队列里面取任务继续放到调用栈里面；9.取到的第一个任务，就是前面 async1 放进去的Promise，执行Promise时候，遇到resolve或者reject函数，这次会又被放到任务队列中等待，然后再次跳出 async1函数 继续下一个任务！！！10.接下来取到的下一个任务，就是前面 new Promise 放进去的 resolve回调，执行then，所以第六个输出的是：”y”;11.调用栈再次空出来了，事件循环就取到了下一个任务,async1 函数中的 async2返回的promise对象的resolve或者reject函数执行，因为 async2 并没有return任何东西，所以这个resolve的参数是undefined；12.此时 await 定义的这个 Promise 已经执行完并且返回了结果，所以可以继续往下执行 async1函数 后面的任务了，那就是“console.log(‘b’)”，所以第七个输出的是：”b”;13.调用栈再次的空了出来终于执行setTimeout的宏任务，所以第八个输出的是：”e”哇(@ο@) 哇～，解决了小伙伴们明白没有，希望大家了解了就再也不怕面试这种题目啦！本想着简单的写下面试题的解决步骤没想到一下子写了这么多，耐心读到这里的小伙伴都是非常棒的，愿你在技术的路上越走越远！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo搭建自己博客(三) 多设备管理]]></title>
    <url>%2F2019%2F02%2F21%2FGitHub-Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[介绍：正常情况下, 我们博客的相关配置信息都是在本地的, 并未上传服务器, 这样当我们想在其他设备, 比如公司的电脑或者原电脑重装了系统, 那么我们便无法再维护我们的博客了一、环境配置安装Node.js安装git安装hexo二、创建分支hexo生成的静态博客文件都是上传到GitHub上的, 且默认放在master分支上, 而一些相关的配置文件都在本地hexo的源文件（部署环境文件）可以都放在hexo分支上（可以新创建一个hexo分支），换新电脑时，直接git clone hexo分支1、仓库新建hexo分支在Github的username.github.io仓库上新建一个hexo(分支名字可自定义)分支, 在下图箭头位置输入分支名字,完成创建；2、设置默认分支切换到该hexo分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo,然后点击update进行保存；三、配置文件上传Github该步骤需要在博客配置文件和主题配置文件所在的电脑上操作，想了解git相关命令，请移步这里1.克隆hexo分支1.1 在合适位置将上述新建的hexo分支克隆到本地, git clone git@github.com:Sandop/Sandop.github.io.git，克隆地址换成自己的地址；1.2 在终端中cd进入该username.github.io文件目录,cd username.github.io；1.3 在当前目录使用Git Bash执行git branch命令查看当前所在分支，应为新建的分支hexo2.上传部署文件2.1 先将本地博客的部署文件（Hexo博客项目目录下的全部文件）全部拷贝进username.github.io文件目录中去2.2 准备将所有的文件都提交到hexo分支，提交时考虑以下注意事项：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，否则提交主题文件夹会失败可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可2.3 最后用终端或者管理工具将所有文件提交到hexo分支,命令git add .、git commit -m &quot;first commit hexo branch&quot;（引号内容可改）、git push;2.4 master分支和hexo分支各自保存着一个版本。master分支用于保存博客静态资源，提供博客页面供人访问；hexo分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内也不会有任何冲突四、同步到其他电脑将新电脑的生成的ssh key添加到GitHub账户上；在新电脑上克隆username.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以需要install下)；在新电脑上安装hexo命令,npm install -g hexo；到这里了就可以开始在自己的新电脑上写博客了！5.1 编辑、撰写文章或其他博客更新改动5.2 依次执行git add .、git commit -m &#39;***&#39;（引号内容为描述提交内容）、git push指令，保证xxx分支版本最新5.3 执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d指令，完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！每次换电脑更新博客的时候, 在修改之前最好也要git pull拉取一下最新的更新]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo搭建自己博客(二) Next主题配置]]></title>
    <url>%2F2019%2F02%2F19%2FGitHub-Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2-%E4%BA%8C-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、基本配置在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。1、站点基本设置在站点配置文件 即博客根目录下的_config.yml中123456789# Sitetitle: Sando博客 subtitle: 代码日记 description: 寄杂志第keywords:author: Sandolanguage: zh-Hanstimezone:2、头像设置2.1 设置头像在站点配置文件 中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）12#侧边栏头像设置avatar: /images/user.jpg2.2 头像旋转动画打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125; img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; /* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;3、主题布局设置在主题配置文件即在next主题目录下的_config.yml文件中将scheme设定为Pisces,可根据个人喜好设置成其他的值12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini4、菜单项设置在主题配置文件中的menu中设置，增添一个movies注：千万不要在这设置中文，后面的值那是查找文件的地方！如下1234567891011menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th #archives: /archives #search: /search #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404 movies: /movies || film这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联。比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 movies: 电影5、菜单项图标设置在主题配置文件中对应的字段是menu_icons。格式为item name：icon name，其中item name与所配置的菜单名字对应，icon name是Font Awesome图标的名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。123456789menu_icons: enable: true home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat movies: film新建的栏目icon，需要在Font Awesome图标库存在，例如新建的movies，在图标库中查询选择film图标，在主题配置文件的menu_icons中，更改movies: film6、侧栏位置设置在主题配置文件中修改主题目录下sidebar的position值1234sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right7、添加标签页面前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面在git bush中输入hexo new page tags在新建的index.md文件中添加type: “tags”12345---title: tagsdate: 2019-02-18 17:16:00type: &quot;tags&quot;---当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可，如：成功后为8、侧边栏社交栏目侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中（1）链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等（2）设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。其中seoial_icons节点中后面的值是http://fontawesome.io/icons/ 中提供的图标的名称。之后其他链接如推特，微博等都可自行增减。1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo9、显示当前浏览进度主题配置文件 即themes/*/_config.yml中scrollpercent更改为true,b2t改为true返回顶部及浏览进度显示在左侧sidebar之下，改为false显示在右下角二、个性化设置1、添加萌萌哒二次元看板娘英文介绍中文介绍1.1、安装插件npm install --save hexo-helper-live2d1.2、配置请向根目录的 _config.yml 文件或主题的 _config.yml 文件中添加配置.1234567891011121314151617live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true模型连接配置详细介绍1.3、配置文件配置文件有很多方法这里主要讲我使用的方法：详情请参考如下：英文介绍中文介绍1.3.1 在博客根目录下建文件夹live2d_models；1.3.2 再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;；1.3.3 再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json；1.4、安装模型在命令行（即Git Bash）运行以下命令即可：npm install --save live2d-widget-model-&lt;你喜欢的模型名字&gt;模型安装1.5、查看结果在命令行（即Git Bash）运行以下命令， 在http://127.0.0.1:4000/查看测试结果：hexo clean &amp;&amp; hexo g &amp;&amp; hexo s1.6、更改模型若更改模型请从第二步更改model.use；删除第三步原有文件，重新创建，安装模型，查看结果2、实现fork me on github2.1、点击 这里 挑选自己喜欢的样式，并复制代码2.2、然后粘贴刚才复制的代码到themes/*/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址2.3、若位置不对，在 img 标签中修改 style=&quot;position:fixed;top:0;right:0&quot;3、设置网站的图标Favicon在EasyIcon或者Iconfont中找一张（32*32）的ico图标，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件 ：4、首页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入：12345678//文章内容添加边框阴影.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;5、网站顶部加载条修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图：6、统计文章阅读量通过leanCloud统计您网站的文章阅读量1.注册LeanCloud, 并创建一个你自己的应用;2.点击图片右上角的设置图标进入应用界面;3.到此，你的应用创建成功，继续表的创建,创建表，并将表的名字命名为：Counter, 如图:4.打开设置 -&gt; 应用key 获取App ID和App Key;5.最后打开主题配置文件: themes/*/_config.yml;1234leancloud_visitors: enable: true app_id: #你的app_id app_key: #你的的app_key6.完成配置并重新编译。到此您已经成功设置了阅读量的统计7、文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;然后在文章上写上password: ****,如下：8、修改链接URL编辑 站点配置文件下的 _config.yml 文件，修改其中的 permalink字段：permalink: :category/:title/9、文章置顶9.1 安装插件npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save9.2 在需要置顶的文章中加上top即可，数值越大文章越靠前1234567---title: &apos;GitHub + Hexo搭建自己博客(二) Next主题配置 &apos;date: 2019-02-19 15:35:40tags: [hexo,github]categories: blog,hexo,nexttop: 10---9.3 设置置顶标志打开：/themes/*/layout/_macro/post.swig，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，插入如下代码：12345&#123;% if post.top %&#125; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;如下：10、隐藏网页底部powered By Hexo / 强力驱动第一种方法：在主题配置文件中，找到footer,配置如下：12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: heart # If not defined, will be used `author` from Hexo main config. copyright: Sando # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false第二种方法：打开themes/next/layout/_partials/footer.swig,使用&lt;!-- --&gt;隐藏之间的代码即可，或者直接删除。位置如图：11、实现统计功能1.在根目录下安装 hexo-wordcount,运行：npm install hexo-wordcount --save2.然后在主题配置文件中，配置如下：12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true12、网站底部字数统计1.在根目录下安装 hexo-wordcount,运行：npm install hexo-wordcount --save2.然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt;13、添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为skip_render: README.md14、修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成15、添加RSS1.站点根目录下安装插件，npm install --save hexo-generator-feed;2.在站点配置文件_config.yml中，添加如下内容：123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed3.然后再主题配置文件中配置rss;1rss: /atom.xml4.配置完之后运行：hexo clean &amp;&amp; hexo g &amp;&amp; hexo s;5.重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中16、点击出现桃心效果1.在路径/themes/*/source/js/src里面新建love.js文件并将代码复制进去；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950! function (e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function () &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document);2.在\themes\*\layout\_layout.swig文件末尾&lt;/body&gt;之前添加12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt;3.我选择的是社会主义核心价值观的特效，因为我们都是社会主义接班人！！123456789101112131415161718192021222324252627282930313233343536373839404142(function() &#123; var T_color = "";//字体颜色,你不设置就是随机颜色, var T_size = [10,20];//文字大小区间,不建议太大 var T_font_weight = "bold";//字体粗斜度--&gt;normal,bold,900 var AnimationTime = 1500;//文字消失总毫秒 var Move_up_Distance = 388;//文字移动距离,正数代表上移，反之下移 var a_index = 0; $("html").click(function(e)&#123; var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正" ,"法治", "爱国", "敬业", "诚信", "友善"); var $i = $("&lt;span/&gt;").text(a[a_index]); a_index = (a_index + 1) % a.length; var x = e.pageX,y = e.pageY; var x_color = "#" + ('00000' + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).substr(-6);//--&gt;随机颜色 //console.log(x_color); if(T_color.length&gt;=4)&#123; x_color = T_color; &#125; var x_size = Math.random()*(T_size[1]-T_size[0]) + T_size[0]; x_size += "px"; $i.css(&#123; "z-index": 99999, "top": y - 20, "left": x, "position": "absolute", "font-weight": "bold", "font-size":x_size, "color": x_color &#125;); $("html").append($i); $i.animate(&#123;"top": y-Move_up_Distance,"opacity": 0&#125;,AnimationTime,function() &#123; $i.remove(); &#125;); &#125;);&#125;)();17、修改文章内链接文本样式1.修改文件 themes\*\source\css\_common\components\post\post.styl，在末尾添加如下css样式，：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;18、在文章末尾添加“本文结束”标记1.在路径 \themes\*\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;2.打开\themes\*\layout\_macro\post.swig文件，在post-body 之后， post-footer之前添加如下代码（post-footer之前两个DIV）12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;3.打开主题配置文件（_config.yml),在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true4.完成以上设置之后，在每篇文章之后都会添加如此效果图19、自定义鼠标样式打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码：1234567// 鼠标样式 * &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword2.ico"),auto!important &#125; :active &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword1.ico"),auto!important &#125;20、Canvas背景在主题配置文件中，找到Canvas配置项，可以应用NNext自带的Canvas特效，如下：想要更改颜色和数量？修改文件：/themes/next/source/lib/canvas-nest/canvas-nest.min.js,修改参考21、修改内容区域的宽度编辑主题的 source/css/_variables/custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px但是此方法不适用于 Pisces Scheme，对于 Pisces Scheme，需要同时修改 header 的宽度、.main-inner 的宽度以及 .content-wrap 的宽度。例如，使用百分比（Pisces 的布局定义在 source/css/_schemes/Picses/_layout.styl 中）123.header&#123; width: 60%; &#125;.container .main-inner &#123; width: 60%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;超过一定宽度后（一行内文字太多导致换行跨度太大），阅读体验不好，我调整的宽度为60%，各位可以自行测试进行调整22、打赏功能1.准备支付宝和微信二维码，存放在themes/*/source/images2.在主题配置文件（_config.yml）中进行设置1234# Rewardreward_comment: 谢谢请我吃辣条！wechatpay: /images/wechatpay.pngalipay: /images/alipay.jpg3.修复图片闪动bug，修改next/source/css/_common/components/post/post-reward.styl，注释wechat:hover和alipay:hover23、配置Valine评论系统1.Valine 是一款基于Leancloud的快速、简洁且高效的无后端评论系统；2.获取Leancloud的APP ID和 APP KEY, 上面第六步设置中已经介绍了获取方法；3.打开主题配置文件: themes/*/_config.yml;12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: # your leancloud application appid appkey: # your leancloud application appkey notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 在这里说点什么吧... # comment box placeholder avatar: identicon # 评论表头样式 /mm/identicon/monsterid/wavatar/retro/hide guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size4.其他相关配置和邮件提醒方式可查看Valline详细配置官网24、添加搜索功能1.在根目录下安装hexo-generator-searchdb插件，npm install hexo-generator-searchdb --save;2.站点配置文件中添加以下字段12345search: path: search.xml field: post format: html limit: 100003.编辑主题配置文件启用本地搜索123# Local searchlocal_search: enable: true25、不蒜子访问统计1.编辑 主题配置文件 themes/*/_config.yml中的busuanzi_count的配置项即可;123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer:2.找到主题调用不蒜子的swig文件\themes*\layout_third-party\analytics\busuanzi-counter.swig3.更改域名1234把原有的：&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;域名改一下即可：&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;26、添加404公益界面1.在根目录下输入hexo new page 404;2.打开刚新建的页面文件，默认在 Hexo 文件夹根目录下 /source/404/index.md；3.将文件名index.md改为404.html;4.在文件中写入内容，这里使用的是腾讯公益；12345678910111213141516---title: 404 Not Found：该页无法显示toc: falsecomments: falsepermalink: /404---&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" homePageName="返回首页" homePageUrl="https://sandop.github.io"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;5.将返回首页的链接更改为自己的链接。27、网页代码压缩网上有很多相关的博文，常规的做法是使用gulp来进行压缩，但是没有成功，所以更换为hexo-neat压缩插件进行。1.站点根目录下安装插件npm install hexo-neat --save；2.修改站点配置文件，在末尾添加以下代码；12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js'3.执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s查看效果。28、添加网站底部跳动的心1.在主题配置文件中（themes/*/_config.yml）,更改footer;12footer: icon: heart2.编辑标签,在/themes/*/layout/_partials/footer.swig中，span中增加id=&quot;heart&quot;;1&lt;span class="with-love" id="heart"&gt;3.编辑css,在themes/*/source/css/_custom/custom.styl中更改样式如下：12345678910111213// 自定义页脚跳动的心样式@keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 168);&#125;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo搭建自己博客(一) 基本内容]]></title>
    <url>%2F2019%2F02%2F18%2FGitHub%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2(%E4%B8%80)%20%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[一、基本环境1、安装Node.js和配置好Node.js环境NodeJs安装（Windows版本）2、安装Git和配置好Git环境Git安装二、Hexo安装1、在自己认为合适的地方创建文件夹，并进入2、安装Hexo，输入npm install hexo -g,并检查是否安装成功hexo -v3、初始化文件，输入hexo init4、安装所需组件，输入npm install5、生成静态文件，输入hexo g 或者 hexo generate6、启动本地服务，输入hexo s 或者 hexo server若页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入hexo server -p 端口号来改变端口号，例如hexo server -p 50007、若能看见如下图就成功啦三、创建GitHub仓库1、创建项目注意：项目必须要遵守格式：账户名.github.io2、查看项目在新建项目的setting设置中，可以看到GitHub Pages板块，如下图说明创建成功，点击https://账户名.github.io/可以看到自己的博客四、关联博客1、设置Git的user name和email如果是第一次使用Git需要在Git Base Here 中分别输入git config --global user.name &quot;用户名&quot; 及 git config --global user.name &quot;邮箱&quot;2、创建SSH Key在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。也可以输入cd ~/.ssh检查是否有.ssh文件夹，输入ls，列出该文件下的内容。下图说明存在如果没有，打开Git Bash，创建SSH Key：ssh-keygen -t rsa -C &quot;youremail@example.com&quot;你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。3、添加SSH Key(1).登陆GitHub，打开“settings”，“SSH and GPG Keys”页面(2).填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容(3).点“Add Key”，你就应该看到已经添加的Key(4).输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了4、配置Deployment在博客的根目录文件夹中，找到_config.yml文件1234deploy: type: git repository: git@github.com:Sandop/Sandop.github.io.git branch: master注意： 1.每个冒号之后必须有空格；2.repository中的用户名更改为自己的用户名5、安装扩展在生成以及部署文章之前，需要安装一个扩展npm install hexo-deployer-git --save6、生成部署输入命令hexo g及hexo d7、部署成功部署成功后访问你的地址：http://用户名.github.io。那么将看到自己的博客五、设置主题在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。PS：需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。1、安装 NexT主题在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：git clone https://github.com/iissnan/hexo-theme-next themes/next2、启用主题当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。3、查看效果在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。然后在本地查看效果hexo s -g //生成静态文件，启动本地服务4、同步博客在本地浏览没有问题之后就可以同步到博客 执行hexo d5、访问我的hexo+github博客可以访问我的git博客来查看效果： https://sandop.github.io/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
